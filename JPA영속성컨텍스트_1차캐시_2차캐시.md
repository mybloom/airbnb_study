# 04airbnb JPA 영속성컨텍스트, 1차캐시 , 2차캐시


##  1차 캐시, 2차 캐시에 접근할 수 있는 경우와 새로 쿼리를 날려야 하는 경우는 언제 차이가 있는지 


## 영속성 컨텍스트
- 1차 캐시
  - @Id 가 붙어 있는 식별자로 엔티티 구분
  - [ ] findByName은 1차캐시에서 가져오지 않는 것일까? 개발하면서 쿼리 실행 로그를 확인해보자. 
- 동일성보장
- 트랜잭션 지원하는 쓰기 지연
  - 트랜잭션 안에서 이뤄지는 insert, update 를 저장소에 가지고 있다가 트랜잭션이 커밋되는 순간 한번에 DB에 요청하는 것. 
  - 한 트랜잭션이 테이블에 접근하는 시간을 줄일 수 있는 장점이 있다. 
  - 쓰기 지연 발생 확인 
    - INSERT : IDENTITY 전략을 사용하므로 insert의 경우 쓰기 지연이 이뤄지지 않는다. 
    - [ ] UPDATE : 확인 해봐야 하지만 영속성 컨텍스트의 엔티티를 수정난 이후 , db 요청이 생기는 메서드 호출(같은 테이블의 id기반 조회가 아닌 것이나 insert쿼리 발생하는 것, AUTO FLUSH라 부르는 것 같다.) 시 그 이전의 것들도 다 db에 쿼리 요청을 한다. 
- 변경 감지


## 1차 캐시
- 영속성 컨텍스트 내에 엔티티 보관하는 저장소
- 유효범위 
  - `트랜잭션 시작하고 종료`할 때까지만 유효
  - 클라이언트 요청/종료까지 유효 : Http request와 생명 주기가 같은가 ?
- 같은 엔티티일때 객체 동일성(==)을 보장

## 2차 캐시
- 애플리케이션 단위의 공유 캐시
- 유효범위
  - `애플리케이션 범위 캐시`
  - 애플리케이션 종료할 때까지 캐시 유지
- 캐시 된 객체 사용 방법
  - 트랜잭션 요청시 캐시 한 객체를 직접 반환하지 않고 `복사본`을 만들어서 반환 
- 복사본 반환 이유
  - 동시성 문제를 해결하기 위해서 복사본을 반환하여 여러 곳에서 같은 객체를 동시에 읽고, 수정할 수 있게 한다. 
  - 동시성 문제를 해결하기 위해 객체의 락을 걸면 현재 사용자 요청이 다른 요청에 종속될 수 있다.
  - 트랜잭션에 복사본을 반환하기 때문에 영속성 컨텍스트가 다르면 객체 동일성(==)을 보장하지 않는다. 

### 2차 캐시에 대한 상세 내용

> 캐시 동시성 전략 설정 @Cache(usage = 이부분 )
- NONE : 캐시를 설정하지 않는다.
- READ_ONLY : 읽기 전용으로 설정한다. 등록, 삭제는 가능하지만 수정은 불가능하다. 참고로 읽기 전용인 불변 객체는 수정되지 않으므로 하이버네이트는 2차 캐시를 조회할 때 객체를 복사하지 않고 원본 객체를 반환한다.
- NONSTRICT_READ_WRITE : 엄격하지 않은 읽고 쓰기 전략이다. 동시에 같은 엔티티를 수정하면 데이터 일관성이 깨질 수 있다. EHCACHE는 데이터를 수정하면 캐시 데이터를 무효화하한다.
- READ_WRITE : 읽고 쓰기가 가능하도 READ_COMMITTED 정도의 격리 수준을 보장한다. EHCACHE는 데이터를 수정하면 캐시 데이터도 같이 수정한다.
- TRANSACTIONAL : 컨테이너 관리 환경에서 사용할 수 있다. 설정에 따라 REPEATABLE_READ 정도의 격리 수준을 보장받을 수 있다.


> 조사하면서 생긴 궁금증
- DB 단의 락이 있는데 어떻게 2차 캐시와 연동되는지 궁금하다.
- 성능 고려시 db의 실행계획등을 파악하는 것도 중요하지만, 1차 캐시에서 가져오는지 아닌지 파악하는 것도 중요하겠다라는 생각이 들었습니다.


> 키워드, 연관 주제
- auto flush
- id기반 조회 여부에 따른 1차 캐시 사용 유무 
- 2차 캐시는 어떻게 동작하는지 


> 참고자료
- https://jobc.tistory.com/209
- https://gunju-ko.github.io/jpa/2019/01/14/JPA-2%EC%B0%A8%EC%BA%90%EC%8B%9C.html
